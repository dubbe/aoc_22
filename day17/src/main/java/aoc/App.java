/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import java.awt.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;

enum Type {
    ROW,
    PLUS,
    LETTER,
    COLUMN,
    SQUARE
}

class Block {
    public Set<Point> rocks;
    public Type type;

    public Block(Set<Point> rocks, Type type) {
        this.rocks = rocks;
        this.type = type;
    }

    public Block(Type type, int sy) {
        int sx = 2;
        this.type = type;
        switch(type) {
            case ROW:
                rocks = new HashSet<>(Arrays.asList(new Point(0+sx, 0+sy), new Point(1+sx, 0+sy), new Point(2+sx, 0+sy), new Point(3+sx, 0+sy)));
                break;
            case PLUS:
                rocks = new HashSet<>(Arrays.asList(new Point(1+sx, 0+sy), new Point(0+sx, 1+sy), new Point(1+sx, 1+sy), new Point(2+sx, 1+sy), new Point(1+sx, 2+sy)));
                break;
            case LETTER:
                rocks = new HashSet<>(Arrays.asList(new Point(0+sx, 0+sy), new Point(1+sx, 0+sy), new Point(2+sx, 0+sy), new Point(2+sx, 1+sy), new Point(2+sx, 2+sy)));
                break;
            case COLUMN:
                rocks = new HashSet<>(Arrays.asList(new Point(0+sx, 0+sy), new Point(0+sx, 1+sy), new Point(0+sx, 2+sy), new Point(0+sx, 3+sy)));
                break;
            case SQUARE:
                rocks = new HashSet<>(Arrays.asList(new Point(0+sx, 0+sy), new Point(1+sx, 0+sy), new Point(0+sx, 1+sy), new Point(1+sx, 1+sy)));
                break;
        }
    }

    public int Height() {
        return rocks.stream().mapToInt(p -> p.y).max().getAsInt() - rocks.stream().mapToInt(p -> p.y).min().getAsInt();
    }


}

public class App {


    public App() {
    }

    public Block move(Block block, Point p) {
        return new Block(block.rocks.stream().map(r -> new Point(r.x + p.x, r.y + p.y)).collect(Collectors.toSet()), block.type);
    }

    public boolean canMove(Block block, Point p, Set<Point> rocks) {
        return move(block, p).rocks.stream().noneMatch(r -> (r.x < 0 || r.x > 6 || r.y < 0 || rocks.contains(r)));
    }

    public int highestPoint(Set<Point> rocks) {
        return rocks.stream().mapToInt(p -> p.y).max().getAsInt();
    }

    public void print(Block block, Set<Point> rocks, int heighestPoint) {
        for(int y = heighestPoint+ block.Height(); y >= 0; y--) {
            System.out.print("|");
            for(int x = 0; x < 7; x++) {
                if(block.rocks.contains(new Point(x, y))) {
                    System.out.print("@");
                } else if (rocks.contains(new Point(x, y))) {
                    System.out.print("#");
                } else {
                    System.out.print(".");
                }
            }
            System.out.print("|\n");
        }
        System.out.println("+-------+");
        System.out.println();
    }

    public Block blow(Block block, Set<Point> rocks, char[] wind, int i) {
        int j = i % wind.length;
        //System.out.println("j " + j);
        if (wind[j] == '<') {
            //System.out.println("Jet of gas pushes block left");
            if (canMove(block, new Point(-1, 0), rocks)) {
                return move(block, new Point(-1, 0));
            }
        } else if (wind[j] == '>') {
            //System.out.println("Jet of gas pushes block right");
            if (canMove(block, new Point(1, 0), rocks)) {
                return move(block, new Point(1, 0));
            }
        }
        return block;
    }
    public Integer getSolutionPart1(List<String> input) {
        int startingPoint = 3;
        Type[] types = new Type[] {Type.ROW, Type.PLUS, Type.LETTER, Type.COLUMN, Type.SQUARE};

        Block falling = new Block(types[0], startingPoint);
        Set rocks = new HashSet<Point>();
        System.out.println("The first rock begins falling");
        //print(falling, rocks, startingPoint);
        char[] wind = input.get(0).toCharArray();
        falling = blow(falling, rocks, wind, 0);
        //print(falling, rocks, startingPoint);

        int noBlocks = 1;
        int i = 1;
        while(true) {
            Block block = move(falling, new Point(0, -1));
//            if(noBlocks == 11) {
//                return 0;
//            }
            // Falling
            if(canMove(falling, new Point(0, -1), rocks)) {
                //System.out.println("Rock falls 1 unit");
                //print(block, rocks, startingPoint);
                // Wind
                falling = blow(block, rocks, wind, i);

            } else {
                //System.out.println(falling.rocks);

                rocks.addAll(falling.rocks);

                if(noBlocks == 2022) {
                    System.out.println("###The 2022nd rock begins falling");
                    return highestPoint(rocks) + 1;
                }
                int test = noBlocks % 5;

                startingPoint = 4 + highestPoint(rocks);

                block = new Block(types[test], startingPoint);
                //print(block, rocks, startingPoint);
                // Wind
                falling = blow(block, rocks, wind, i);
                noBlocks++;
            }

            i++;
            //print(falling, rocks, startingPoint);
        }

    }


    public void printRow(Set<Point> rocks, int y) {
        for(int x = 0; x < 7; x++) {
            if (rocks.contains(new Point(x, y))) {
                System.out.print("#");
            } else {
                System.out.print(".");
            }
        }
        System.out.println();
    }

    public String getSolutionPart2(List<String> input) {
        int startingPoint = 3;
        Type[] types = new Type[] {Type.ROW, Type.PLUS, Type.LETTER, Type.COLUMN, Type.SQUARE};

        Block falling = new Block(types[0], startingPoint);
        Set rocks = new HashSet<Point>();
        System.out.println("The first rock begins falling");
        //print(falling, rocks, startingPoint);
        char[] wind = input.get(0).toCharArray();
        falling = blow(falling, rocks, wind, 0);
        //print(falling, rocks, startingPoint);

        long noBlocks = 1;
        int i = 1;
        int blocksSinceLast = 0;

        int lastW = 0;
        int firstStackHeight = 0;
        long firstNoBlocks = 0;
        int repeatingW = 0;
        int heightPerRepeat = 0;
        long blocksPerRepeat = 0;
        int repeats = 0 ;

        boolean found = false;
        while(!found) {
            Block block = move(falling, new Point(0, -1));
//            if(noBlocks == 11) {
//                return 0;
//            }
            // Falling
            if(canMove(falling, new Point(0, -1), rocks)) {
                //System.out.println("Rock falls 1 unit");
                //print(block, rocks, startingPoint);
                // Wind
                falling = blow(block, rocks, wind, i);

            } else {
                //System.out.println(falling.rocks);

                rocks.addAll(falling.rocks);


                int y = highestPoint(rocks);


                //System.out.println();
                if(!rocks.contains(new Point(0, y)) &&
                        !rocks.contains(new Point(1, y)) &&
                        rocks.contains(new Point(2, y)) &&
                        rocks.contains(new Point(3, y)) &&
                        rocks.contains(new Point(4, y)) &&
                        rocks.contains(new Point(5, y)) &&
                        !rocks.contains(new Point(6, y))) {
                    int w = i%wind.length;



                    // System.out.println(String.format("%-40s", i + " " + blocksSinceLast + " " + falling.type + " blocks: " + noBlocks + " w: " + w));
                    if(w > lastW && repeatingW == 0) {
                        lastW = w;
                    } else if(repeatingW == 0)  {
                        System.out.println("#### is this the first time?");
                        firstStackHeight = y;
                        firstNoBlocks = noBlocks;
                        repeatingW = w;
                        System.out.println("#### firstStackHeight: " + firstStackHeight + " firstNoBlocks: " + firstNoBlocks + " repeatingW: " + repeatingW);
                    } else if(w == repeatingW) {
                        repeats++;
                        heightPerRepeat = y - firstStackHeight;
                        blocksPerRepeat = noBlocks - firstNoBlocks;
                        System.out.println("height: " + heightPerRepeat + " " + heightPerRepeat / repeats + " blocks per repeat: " + blocksPerRepeat / repeats);
                        System.out.println("w: " + w + " direction: " + wind[w] +  " type: " + falling.type);
                        found = true;
                        //return "0";
                    }
                    blocksSinceLast = 0;
                    //System.out.println("We found a first row at " + y +" when block " + falling.type + " was falling");
                    //printRow(rocks, y);
                } else {
                    //System.out.print(String.format("%-30s", "-"));
                }
                //printRow(rocks, y);


                if(noBlocks == 1000000) {
                    System.out.println("###The 10000 rock begins falling");
                    return  Long.toString(highestPoint(rocks) + 1);
                }
                int test = (int) (noBlocks % 5);



                startingPoint = 4 + highestPoint(rocks);

                block = new Block(types[test], startingPoint);
//                if(types[test] == Type.ROW) {
//                    System.out.println("###The " + noBlocks + "th rock begins falling");
//                    print(block, rocks, startingPoint);
//                }
                //print(block, rocks, startingPoint);
                // Wind
                falling = blow(block, rocks, wind, i);
                blocksSinceLast++;
                noBlocks++;
            }

            i++;


            //print(falling, rocks, startingPoint);
        }

        long blocks = 1000000000000L - firstNoBlocks;
        long remaining = blocks % blocksPerRepeat;
        long d = (blocks - firstNoBlocks) / blocksPerRepeat;
        System.out.println("blocks: " + blocks + " remaining: " + remaining + " d: " + d);

        int iNoBlocks = 0+2;
        i = repeatingW+1;
        int bl = 0;

        rocks = new HashSet<Point>();
        startingPoint = 3;
        System.out.println(falling.type);
        falling = new Block(falling.type, startingPoint);
        falling = blow(falling, rocks, wind, i);
        i++;
        while(true) {
            Block block = move(falling, new Point(0, -1));
//            if(noBlocks == 11) {
//                return 0;
//            }
            // Falling
            if(canMove(falling, new Point(0, -1), rocks)) {
                //System.out.println("Rock falls 1 unit");
                //print(block, rocks, startingPoint);
                // Wind
                falling = blow(block, rocks, wind, i);

            } else {
                //System.out.println(falling.rocks);

                rocks.addAll(falling.rocks);
                System.out.println("noBlocks: "  + iNoBlocks);
                if(iNoBlocks - 2 == remaining) {
                    System.out.println("###The 2022nd rock begins falling");
                    bl = highestPoint(rocks) + 1;
                    break;
                }
                int test = iNoBlocks % 5;

                startingPoint = 4 + highestPoint(rocks);

                block = new Block(types[test], startingPoint);
                //print(block, rocks, startingPoint);
                // Wind
                falling = blow(block, rocks, wind, i);
                iNoBlocks++;
            }

            i++;
            //print(falling, rocks, startingPoint);
        }

//        System.out.println("remaining blocks: " + remaining);
//        System.out.println("t: " + t);
        return Long.toString((d * (heightPerRepeat)) + firstStackHeight + bl);
    }

    public static void main(String[] args) throws IOException {
        List<String> input = parseInput("input.txt");
        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2"))
            System.out.println(new App().getSolutionPart2(input));
        else
            System.out.println(new App().getSolutionPart1(input));
    }

    private static List<String> parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename))
                .collect(Collectors.toList());
    }
}
