/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import java.awt.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.*;
import java.util.List;
import java.util.regex.Matcher;
import java.util.regex.Pattern;
import java.util.stream.Collectors;


public class App {

    class Node {

        int index;
        long value;
        Node nextNode;
        Node previousNode;

        public Node(int index, long value) {
            this.index = index;
            this.value = value;
        }

    }

    public class CircularLinkedList {
        private Node head = null;
        private Node tail = null;
        private int size = 0;

        public void add(long value) {
            Node newNode = new Node(size, value);

            if (head == null) {
                head = newNode;
                tail = head;
            } else {
                newNode.previousNode = tail;
                newNode.nextNode = head;

                tail.nextNode = newNode;
                head.previousNode = tail;
                tail = newNode;
            }

            size++;
        }

        public void addAfterSteps(int index, long value) {
            Node newNode = new Node(index, value);
            Node currentNode = head;
            long steps = value;

            if(value < 0) {
                steps = (steps * -1);
            }

            if(steps > (size)) {
                steps = steps%(size);

            }

            if(value < 0) {
                steps = steps + 2;
            }


            for(long i = 0; i < steps-1; i++) {
                if(value < 0) {
                    currentNode = currentNode.previousNode;
                } else {
                    currentNode = currentNode.nextNode;
                }
            }

            Node nextNode = currentNode.nextNode;
            currentNode.nextNode = newNode;
            newNode.previousNode = currentNode;
            newNode.nextNode = nextNode;
            nextNode.previousNode = newNode;
            size++;
        }

        public void print() {
            Node current = head;
            if (head != null) {
                do {
                    System.out.print(current.value + ", ");
                    current = current.nextNode;
                } while (current != head);
            }
            System.out.println();
        }

        public long get(int index) {

            Node current = head;
            if (head != null) {
                do {
                    if (current.index == index) {
                        return current.value;
                    }
                    current = current.nextNode;
                } while (current != head);
            }
            return 0;
        }

        public long getLarge(int index) {
            if(index > size) {
                int test= index % size;
                index = test;
            }
            Node current = head;
            //System.out.println(head.value);
            for(int i = 0; i < index; i++) {
                current = current.nextNode;
            }

            return current.value;
        }

        public void setHead(long value) {
            Node current = head;
            if (head != null) {
                do {
                    if (current.value == value) {
                        head = current;
                        tail = current.previousNode;
                        break;
                    }
                    current = current.nextNode;
                } while (current != head);
            }
        }

        public void delete(long value) {
            Node current = head;
            if (head != null) {
                do {
                    if (current.value == value) {
                        if (current == head) {
                            head = current.nextNode;
                            head.previousNode = tail;
                            tail.nextNode = head;
                        } else if (current == tail) {
                            tail = current.previousNode;
                            tail.nextNode = head;
                            head.previousNode = tail;
                        } else {
                            current.previousNode.nextNode = current.nextNode;
                            current.nextNode.previousNode = current.previousNode;
                            head = current.nextNode;
                            tail = current.previousNode;
                        }
                        size--;
                    }
                    current = current.nextNode;
                } while (current != head);
            }
        }

        public int size() {
            return size;
        }
    }

    public App() {
    }

    public String getSolutionPart1(List<String> input) {
        CircularLinkedList cll = new CircularLinkedList();
        for(String line : input) {
            cll.add(Integer.parseInt(line));
        }
        for(int i = 0; i<cll.size(); i++) {
            long value = cll.get(i);
            if(value == 0) {
                continue;
            }
            cll.delete(value);
            cll.addAfterSteps(i, value);
        }

        cll.setHead(0);
        System.out.println("After 1 rounds (size: " + cll.size() + ")");
        cll.print();

        long value1 = cll.getLarge(1000);
        long value2 = cll.getLarge(2000);
        long value3 = cll.getLarge(3000);

        long sum = value1 + value2 + value3;
        System.out.println(value1 + " " + value2 + " " + value3 + " = " + sum);
        return Long.toString(sum);
    }
    public String getSolutionPart2(List<String> input) {
        CircularLinkedList cll = new CircularLinkedList();
        System.out.println(Long.MAX_VALUE);
        System.out.println(Long.MIN_VALUE);

//        input.sort(new Comparator<String>() {
//            public int compare(String s1, String s2) {
//                int i1 = Integer.parseInt(s1);
//                int i2 = Integer.parseInt(s2);
//                return Integer.compare(i1, i2);
//            }
//        });

        for(String line : input) {
            System.out.println(Long.parseLong(line) + " * 811589153 = " + Long.parseLong(line) * 811589153L);
            cll.add(Long.parseLong(line) * 811589153L);
        }

        for(int x = 0; x < 10; x++) {
            for (int i = 0; i < cll.size(); i++) {
                long value = cll.get(i);
                if (value == 0) {
                    continue;
                }
                cll.delete(value);
                cll.addAfterSteps(i, value);
            }
            System.out.println("After " + (x+1) + " rounds (size: " + cll.size() + ")");
            cll.setHead(0);
            cll.print();
        }
        long value1 = cll.getLarge(1000);
        long value2 = cll.getLarge(2000);
        long value3 = cll.getLarge(3000);

        long sum = value1 + value2 + value3;
        System.out.println(value1 + " + " + value2 + " + " + value3 + " = " + sum);
        return Long.toString(sum);
    }

    public static void main(String[] args) throws IOException {
        List<String> input = parseInput("input.txt");
        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2"))
            System.out.println(new App().getSolutionPart2(input));
        else
            System.out.println(new App().getSolutionPart1(input));
    }

    private static List<String> parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename))
                .collect(Collectors.toList());
    }
}
