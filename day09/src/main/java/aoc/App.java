/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package aoc;

import java.awt.*;
import java.io.IOException;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.StandardWatchEventKinds;
import java.util.*;
import java.util.List;
import java.util.stream.Collectors;


public class App {

    public App() {
    }

    public boolean headNextToBody(Point head, Point tail)
    {
        for(int y=-1;y<=1;y++) {
            for (int x=-1;x<=1;x++) {
                if(head.x == tail.x + x && head.y ==tail.y + y) {
                    return true;
                }
            }
        }
        return false;
    }

    public boolean isDiagonal(Point head, Point tail) {
        return head.x != tail.x && head.y != tail.y;
    }

    public Point move(String direction, Point p) {
        switch (direction) {
            case "R":
                return new Point(p.x + 1, p.y);
            case "L":
                return new Point(p.x -1, p.y);
            case "U":
                return new Point(p.x, p.y +1);
            case "D":
                return new Point(p.x, p.y - 1);
            default:
                return p;
        }
    }

    public Integer getSolutionPart1(List<String> input) {
        Map<Point, Integer> grid = new HashMap<>();
        Point head = new Point(0,0);
        Point tail = new Point(0,0);

        for(String line: input) {
            String[] instructions = line.split(" ");
            int steps = Integer.parseInt(instructions[1]);
            for(int i = 0; i < steps;i++) {
                head = move(instructions[0], head);

                if (!headNextToBody(head, tail)) {
                    tail = move(instructions[0], tail);
                    if(instructions[0].equals("R") || instructions[0].equals("L")) {
                        tail.y = head.y;
                    } else {
                        tail.x = head.x;
                    }
                }
                grid.put(tail, 1);
            }
        }

        return grid.size();
    }

    public Integer getSolutionPart2(List<String> input) {
        Set<Point> grid = new HashSet<>();
        Point head = new Point(0,0);
        Map<Integer, Point> tails = new HashMap<>();

        for(int i=0;i<9;i++) {
            tails.put(i,new Point(0,0));
        }

        for(String line: input) {
            String[] instructions = line.split(" ");
            int steps = Integer.parseInt(instructions[1]);
            for(int i = 0; i < steps;i++) {
                head = move(instructions[0], head);
                Point lastPart = head;
                Map<Integer, Point> newTails = new HashMap<>();
                String lastInstruction = instructions[0];

                for(int j=0;j<tails.size();j++) {
                    Point tail = tails.get(j);
                    if (!headNextToBody(lastPart, tail)) {

                        tail = move(lastInstruction, tail);
                        // if diagonal after move
                        if(isDiagonal(lastPart, tail)) {
                            if(lastInstruction.equals("U") || lastInstruction.equals("D")) {
                                if(lastPart.x > tail.x) {
                                    tail = move("R", tail);
                                    lastInstruction = "R";
                                } else {
                                    tail = move("L", tail);
                                    lastInstruction = "L";
                                }
                            } else if(lastInstruction.equals("R") || lastInstruction.equals("L")) {
                                if(lastPart.y > tail.y) {
                                    tail = move("U", tail);
                                    lastInstruction = "U";
                                } else {
                                    tail = move("D", tail);
                                    lastInstruction = "D";
                                }
                            }
                        } else if (!headNextToBody(lastPart, tail)) {
                            if(lastInstruction.equals("U") || lastInstruction.equals("D")) {
                                if(lastPart.x > tail.x) {
                                    tail = move("R", tail);
                                    lastInstruction = "R";
                                } else {
                                    tail = move("L", tail);
                                    lastInstruction = "L";
                                }
                            } else if(lastInstruction.equals("R") || lastInstruction.equals("L")) {
                                if(lastPart.y > tail.y) {
                                    tail = move("U", tail);
                                    lastInstruction = "U";
                                } else {
                                    tail = move("D", tail);
                                    lastInstruction = "D";
                                }
                            }
                        }
                    }
                    lastPart = tail;
                    newTails.put(j, tail);
                }
                tails = newTails;

                grid.add(lastPart);
            }
        }

        return grid.size();
    }

    public static void main(String[] args) throws IOException {
        List<String> input = parseInput("input.txt");
        String part = System.getenv("part") == null ? "part1" : System.getenv("part");
        if (part.equals("part2"))
            System.out.println(new App().getSolutionPart2(input));
        else
            System.out.println(new App().getSolutionPart1(input));
    }

    private static List<String> parseInput(String filename) throws IOException {
        return Files.lines(Path.of(filename))
                .collect(Collectors.toList());
    }
}
